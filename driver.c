#include "whole_include.h"
#include <time.h>

// Function to remove comments from a file
void remove_comments(const char *input_filename, const char *output_filename)
{
    FILE *input_file = fopen(input_filename, "r");
    if (input_file == NULL)
    {
        fprintf(stderr, "Error opening input file %s\n", input_filename);
        exit(1);
    }

    FILE *output_file = fopen(output_filename, "w");
    if (output_file == NULL)
    {
        fprintf(stderr, "Error opening output file %s\n", output_filename);
        exit(1);
    }

    char line[256];
    while (fgets(line, sizeof(line), input_file))
    {
        char *comment_start = strchr(line, '%');
        if (comment_start != NULL)
        {
            *comment_start = '\0';
        }
        int i = strlen(line) - 1;
        while (i >= 0 && (line[i] == ' ' || line[i] == '\t' || line[i] == '\n' || line[i] == '\r'))
        {
            line[i] = '\0';
            i--;
        }
        printf("%s\n", line);
        fprintf(output_file, "%s\n", line);
    }

    fclose(input_file);
    fclose(output_file);
}

// Function to measure execution time
void measure_execution_time()
{
    clock_t start_time, end_time;

    double total_CPU_time, total_CPU_time_in_seconds;

    start_time = clock();

    lexical_analysis();
    // parser();

    end_time = clock();

    total_CPU_time = (double)(end_time - start_time);

    total_CPU_time_in_seconds = total_CPU_time / CLOCKS_PER_SEC;

    printf("\ntotal CPU time : %f", total_CPU_time);
    printf("\ntotal CPU time in seconds : %f", total_CPU_time_in_seconds);
}

void lexical_analysis()
{
    info("Performing Lexical Analysis");
    // Lexer lexer = init_lexer("test.txt");
    // Lexer lexer = init_lexer("test/test_char.txt");
    Lexer lexer = init_lexer("Test_Cases/t1.txt");

    Token tk = getNextToken(lexer);
    // printf("fwd0 %d \n", lexer->fwd_ptr);

    Vector vec = init_vector(TOKEN);
    // push_back(vec, tk1);

    // Token tk = NULL;
    printf("%s \n", lexer->buff1);
    while ((lexer->fp))
    {
        // if(tk1_read)
        // printf("%s\n", token_type_list[tk->type]);
        push_back(vec, tk);
        tk = getNextToken(lexer);
    }

    for (int i = 0; i < vec->size; i++)
    {
        printf("Line No. %ld  ", ((Token)get(vec, i))->line_num);
        if (((Token)get(vec, i))->type == 57)
        {
            printf("Error: %s", ((Token)get(vec, i))->error_msg);
        }
        else
        {
            printf("Lexeme %s       ", (char *)(((Token)get(vec, i))->lexeme_str)->text);
            printf("Token %s", token_type_list[((Token)get(vec, i))->type]);
        }

        printf("\n");
    }

    success("LEXER output printed successfully.");
}

//driver function to allow users to perform an execution of their choice
void driver()
{
    int option;
    do
    {
        printf("\n Options: \n");
        printf("0: For Exit\n");
        printf("1: For Removal of comments\n");
        printf("2: For printing the token list generated by the lexer \n");
        printf("3: For parsing and print parse tree \n");
        printf("4: For measuring the execution time \n");
        printf("Enter your choice: ");
        scanf("%d", &option);

        switch (option)
        {
        case 0:
            printf("Exiting \n");
            break;
        case 1:
            remove_comments("test/t5.txt", "test/t5_wo.txt");
            break;
        case 2:
            lexical_analysis();
            break;
        case 3:
            // parse_and_print_parse_tree();
            // break;
        case 4:
            measure_execution_time();
            break;
        default:
            printf("Invalid option. Please try again.\n");
        }
    } while (option != 0);
}